import numpy as np
import random

# ------------------------------------Subroutine------------------------------------
def Check_n(n,t):
    if n < 2*t or n <= 0:
        print("You need more parties")
        check = 1
    else:
        check = 0
    return check

def Fun_sender(t):
    for i in range (t):
        fun_s.append(random.randint(-10,10))
    return fun_s

def Share(n,t,f_coeff,s):
    for i in range (n):
        num = 0
        for j in range (t):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            num += f_coeff[j]*power
        share.append(num+s)
    return share

def Error(num_e,shares):
    error = shares
    while (num_e):
        position = int(input("The number of the party : "))-1
        error[position] = int(input("The error number : "))
        num_e -= 1
    return error
    
# ------------------------------------Main program------------------------------------
check_n = 1
fun_s = []
share = []
error = []

print("-------------------Start-------------------")

s = int(input("Secret : "))
t = int(input("The degree of f(x) : "))

while (check_n):
    n = int(input("The number of parties (n > 2t) : "))
    check_n = Check_n(n,t)

k = int((n-t-1)/2)
print("The maximum of the number of error : ",k)

f_coeff = Fun_sender(t)
print("The Coefficient of f(x) = ", f_coeff)

shares = Share(n,t,f_coeff,s)
print("The shares are : ",shares)

num_e = int(input("How many errors happen : "))
shares_err = Error(num_e,shares)
print("The shares are redefined : ",shares_err)



# #寫出係數矩陣 A
# A = np.array([
#     [4, -1, -1, -1],
#     [3, -1, -2, -4],
#     [4, -1, -3, -9],
#     [1, -1, -4, -16]
# ])
# # 寫出常數矩陣 B
# B = np.array([-4, -6, -12, -4]).reshape(4, 1)
# # 找出係數矩陣的反矩陣 A_inv
# A_inv = np.linalg.inv(A)
# # 將 A_inv 與 B 相乘，即可得到解答
# ans = A_inv.dot(B)
# print(ans)