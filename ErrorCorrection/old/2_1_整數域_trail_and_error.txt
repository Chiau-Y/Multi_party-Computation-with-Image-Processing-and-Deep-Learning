import random
import numpy as np
from sympy import * 
from itertools import product
from collections import Counter
from numpy.polynomial import Polynomial as P

# ------------------------------------Subroutine------------------------------------
def Egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = Egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def Modinv(a, m):
    g, x, y = Egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

def Check_n(n,t):                                                            # 設定party個數                   
    if n < 2*t or n <= 0:
        print("You need more parties")
        check = 1
    else:
        check = 0
    return check

def Fun_sender(t):                                                          # 創造多項式                                                        
    for i in range (t):
        # fun_s.append(random.randint(-10,10))
        fun_s.append(-1)
    return fun_s

def Share(n,t,f_coeff,s):                                                    # 發送shares  
    for i in range (n):
        num = 0
        for j in range (t):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            num += f_coeff[j]*power
        share.append((num+s))
    return share

def Error(num_e,shares):                                                     # shares被竄改                                                   
    error = shares
    while (num_e):
        position = int(input("The position of the error of the party : "))
        error[position-1] = int(input("The error is : ")) 
        num_e -= 1
    return error

def Matrix_A(shares_err,k,t,n):                                              # A矩陣
    share = shares_err
    k1 = k
    for i in range (n):
        matrix_A1.append(share[i])
        for j in range (k-1):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            matrix_A1.append((share[i]*power))   
    for i in range (n):
        matrix_A2.append(-1)
        num = 0
        for j in range (t+k):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            matrix_A2.append(((-1)*power)) 
    if k == 0:
        k1 += 1
    return np.append(np.array(matrix_A1).reshape(n,k1), np.array(matrix_A2).reshape(n, t+k+1), axis=1) 

def Matrix_b(share,k,n):                                                # b矩陣
    for i in range (1,n+1):
        power = 1
        for j in range (k):
            power *= i
        matrix_b1.append(share[i-1]*power*(-1))      
    return np.array(matrix_b1).reshape(n,1)
    
def Matrix_x(matrix1,matrix2):                                             # 矩陣求解
    global prime_num,A_det_inv,A_inv,ans
    print("===== Square and Non-Singular Matrix=====\n")
    A_inv_temp = np.linalg.inv(matrix1)
    A_det_temp = (round(np.linalg.det(matrix1)))%prime_num
    A_adj = np.around((A_inv_temp*round(np.linalg.det(matrix1))))
    
    A_det_inv = Modinv(A_det_temp,prime_num)
    A_inv = (A_adj*A_det_inv)%prime_num
    ans = A_inv.dot(matrix2)
    return ans % prime_num

def Matrix_x_Pseudo(matrix1,matrix2):                                      # 非方正矩陣求解
    global A_star_temp
    print("===== Non-square Matrix =====\n")
    A_T = np.array(np.transpose(matrix1))
    
    A_star_temp = np.dot(A_T,matrix1)
    A_star_inv_temp = np.linalg.inv(A_star_temp)
    A_star_det_temp = (round(np.linalg.det(A_star_temp)))%prime_num
    A_star_adj = np.around((A_star_inv_temp*round(np.linalg.det(A_star_temp))))
    A_star_det_inv = Modinv(A_star_det_temp,prime_num)
    A_star_inv = (A_star_adj*A_star_det_inv)%prime_num

    A_star = np.dot(A_star_inv,A_T)
    ans = np.dot(A_star,matrix2)%prime_num   
    
    return ans

def Matrix_x_Singular(n,matrix1,matrix2):                                  # 奇異矩陣求解
    print("===== Singular Matrix =====\n")
    Augmented = Matrix(np.hstack((matrix1,matrix2)))
    matrix_rref = np.array(Augmented.rref()[0])
    ans = []
    
    for num in range (2):
        count = 0
        answer = []
        for i in range (n):        
            if max(matrix_rref[n-(i+1)]) == 0:                                   # 判斷有幾列整列皆是0
                count += 1 
        for i in range (n):  
            position_2 = -1    
            sum, p = 0, 1
            for j in range (t+2*k+1): 
                if position_2 == -1:                                             # 判斷有沒有找到第一個1在哪個位置
                    if matrix_rref[n-(i+1)][j] == 1:                             # 判斷1在哪個位置
                        position_2 = j                                           # 要解的未知數的位置
                        if position_2 == (t+2*k):
                            answer.append(matrix_rref[n-(i+1)][j+1])
                            for z in range (count):                              # 通解的未知數全部設0，0的個數count決定
                                answer.append(num)  
                            count = 0      
                else:               
                    sum += -1*matrix_rref[n-(i+1)][j]*answer[(t+2*k+1)-(j+1)]    # (j+1)+(x+1)-1 = t+2*k+1，從頭或從尾開始算
                    p += 1
            if count == 0 and position_2 != (t+2*k):
                sum += matrix_rref[n-(i+1)][t+2*k+1]
                answer.append(sum)  
        ans.append(np.array(answer).reshape(t+2*k+1,1))
    return ans

def Reshape(matrix): 
    ans = []                                                         # 重新排列矩陣
    for num in range (2): 
        matrix_x1 = []
        for i in range (t+2*k+1):
            matrix_x1.append(matrix[num][t+2*k+1-(i+1)][0])
        ans.append(np.array(matrix_x1).reshape(t+2*k+1,1))
    return ans   

def solution_errorposition(a):
    b = (a.roots).real.tolist()
    ans1 = all(x%1 == 0 for x in b) # 確認每個元素是不是整數，將所有bool做and,要等於True
    ans2 = all(x > 0 for x in b) # 確認每個元素是不是，將所有bool做and,要等於True
    return (not (ans1 and ans2)), b

def solution_errorposition_singular(a_s):
    b_s = (a_s.roots).real.tolist()
    ans = all(x%1 == 0 for x in b_s) # 確認每個元素是不是整數，將所有bool做and,要等於True
    return (not ans), b_s

def Solution(matrix):                                                      # 多項式求解(error)
    prime_set = [0,-prime_num,prime_num,-prime_num*2,prime_num*2] 
    if (k==1):
        mod_set = list(product(prime_set,prime_set,prime_set)) # 所有有可能的set(排列組合)
    elif (k==2):
        mod_set = list(product(prime_set,prime_set,prime_set,prime_set)) # 所有有可能的set(排列組合)
    elif (k==3):
        mod_set = list(product(prime_set,prime_set,prime_set,prime_set,prime_set)) # 所有有可能的set(排列組合)
    
    if len(matrix) == 2 : # 奇異矩陣
        solve2, temp_ans2 = [], []            
        for j in range(2):
            solve1 = [1]
            for i in range (2):
                solve1.append(matrix[j][(2-1)-i][0])
            solve2.append(np.poly1d(np.array(solve1)%prime_num))  # mod
    
        for j in range(2):
            count = 0
            start_flag = True 
            res = []
            while(start_flag and (count < pow(len(prime_set),len(solve2[j])+1))):
                solve3 =  solve2[j] + mod_set[count]
                start_flag, temp_ans = solution_errorposition_singular(solve3)
                count+=1                            
            for i in temp_ans:  # 移除重複的
                if i not in res: 
                    res.append(i)  
            temp_ans2.append(res)   
                         
        temp_ans2 = temp_ans2[0]+temp_ans2[1] # 合併
        result = Counter(temp_ans2) # dictionary
        result_list = result.most_common() # dictionary to list
        
        for j in range(len(result_list)):
            if result_list[j][1] > 1: # 找重複的答案
                solution2.append(int(result_list[j][0]%prime_num))  # mod
            else:
                pass    
    else:         # 非奇異矩陣
        solve1 = [1]     
        for i in range (k):
            solve1.append(matrix[(k-1)-i][0])
        solve2 = np.poly1d(np.array(solve1))
      
        start_flag = True       
        count = 0          
        while(start_flag and (count < pow(len(prime_set),len(solve2)+1))):
            solve3 =  solve2 + mod_set[count]          
            start_flag, solution1 = solution_errorposition(solve3)  
            count+=1
        
        for i in range (k):
            if solution1[i] > 0 and solution1[i] <= n:
                solution2.append(int(round(solution1[i])))
    return solution2, solve2

def Orinignal_fun(matrix1,matrix2,matrix3,matrix4): # matrix_x,error_party,shares_err,fun_e
    global unknown,h_Prime,h,variable,solve5
    answer, solve3 = [], []
    variable = [a,b,c,d]   
    
    for i in range (t+k+1):                              # h(x)
        solve3.append(matrix1[((t+2*k+1)-1)-i][0]) 
    h = np.poly1d(solve3)
        
    if (t==1):
        coefficient = [a,b]
    elif (t==2):
        coefficient = [a,b,c]
    elif (t==3):
        coefficient = [a,b,c,d]

    for i in range (t+1):
        unknown = np.poly1d(coefficient)  # 原式
        h_Prime = unknown*fun_e  
        ans = solve(h_Prime[len(h_Prime)-i]-h[len(h)-i],variable[i])
        answer.append(ans[0]%prime_num)
        coefficient[i] = answer[i]
    solve5 = np.poly1d(answer)
    
    for i in range (num_e):  # 更正錯誤
        matrix3[matrix2[i]-1] = int(round(solve5(matrix2[i])))%prime_num
    return matrix3, solve5

# ------------------------------------Main program------------------------------------
check_n = 1
fun_s, share, error  = [], [], []
matrix_A1, matrix_A2, matrix_b1, matrix_x1 = [], [], [], []
answer, solve1, solution2, solve3, solution3 = [], [], [], [], []

a = Symbol('a')
b = Symbol('b')
c = Symbol('c')
d = Symbol('d')

print("\n-------------------Start-------------------")                

s = int(input("Secret : "))                                                 # 秘密(s0) 
t = int(input("The degree of f(x) : "))                                     # 次方(t)
prime_num = int(input("The prime number P : "))                             # 質數(prime)

while (check_n):
    n = int(input("The number of parties (n > 2t) : "))
    check_n = Check_n(n,t)                                                  # party數(n)

k = int((n-t-1)/2)
print("The maximum of the number of error : ",k)                            # 錯誤數量最大值(k_max)          

f_coeff = np.array(Fun_sender(t))                                           # 多項式係數
print("The Coefficient of f(x) = ", f_coeff)

shares = np.array(Share(n,t,f_coeff,s))                                     # shares
print("The shares are : ",shares)

num_e = int(input("\nHow many errors happen : "))                           # 錯誤的數量
shares_err = Error(num_e,shares)                                            # 更改過的shares
print("\nThe shares are redefined : ",shares_err)

matrix_A = np.array(Matrix_A(shares_err,k,t,n))                             # 矩陣A
print("\nMatrix A : \n",matrix_A)

matrix_b = np.array(Matrix_b(shares_err,k,n))                               # 矩陣b
print("Matrix b : \n",matrix_b)

if t+2*k+1 == n:
    if round(np.linalg.det(matrix_A)) == 0:   
        matrix_x_1 = Matrix_x_Singular(n,matrix_A,matrix_b)   
        matrix_x = Reshape(matrix_x_1)
    else:
        matrix_x = Matrix_x(matrix_A,matrix_b)  
else:
    matrix_x = Matrix_x_Pseudo(matrix_A,matrix_b)                           # 解答(矩陣x)

if len(matrix_x) == 2 :
    print("Matrix x : \n",matrix_x[0])
    print("\n",matrix_x[1])
else:
    print("Matrix x : \n",matrix_x)

error_party, fun_e = Solution(matrix_x)                                     # 錯誤的party
error_party.sort()
if len(error_party) == 0:
    print("\nThere is no error in shares.")
    f_coeff = f_coeff.tolist()
    f_coeff.append(s) 
    print("The f(x) is : ",np.poly1d(np.array(f_coeff)))
else:
    print("\nThe error party is : ", error_party)
    shares_corret, fun_org = Orinignal_fun(matrix_x,error_party,shares_err,fun_e)
    print("\nThe correct shares are : ",shares_corret)
    print("The f(x) is : \n",fun_org)

print("\n-------------------END-------------------\n")