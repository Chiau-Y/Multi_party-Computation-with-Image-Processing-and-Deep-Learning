import numpy as np
import random
from sympy import * 

# ------------------------------------Subroutine------------------------------------
def Check_n(n,t):
    if n < 2*t or n <= 0:
        print("You need more parties")
        check = 1
    else:
        check = 0
    return check

def Fun_sender(t):
    a = -1
    for i in range (t):
        # fun_s.append(random.randint(-10,10))
        fun_s.append(-1)
    return fun_s

def Share(n,t,f_coeff,s):
    for i in range (n):
        num = 0
        for j in range (t):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            num += f_coeff[j]*power
        share.append(num+s)
    return share

def Error(num_e,shares):
    error = shares
    while (num_e):
        position = int(input("The position of the error of the party : "))
        error[position-1] = int(input("The error is : "))
        num_e -= 1
    return error

def Matrix_A(shares_err,k,t,n):
    share = shares_err
    k1 = k
    for i in range (n):
        matrix_A1.append(share[i])
        for j in range (k-1):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            matrix_A1.append(share[i]*power)   
    for i in range (n):
        matrix_A2.append(-1)
        num = 0
        for j in range (t+k):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            matrix_A2.append((-1)*power) 
    if k == 0:
        k1 += 1
    return np.append(np.array(matrix_A1).reshape(n,k1), np.array(matrix_A2).reshape(n, t+k+1), axis=1) 
    # return np.array(matrix_A2).reshape(n, t+k+1)

def Matrix_b(shares_err,k,n):  
    for i in range (n):
        power = 1
        for j in range (k):
            power *= (i+1)
        matrix_b1.append(share[i]*power*(-1))      
    return np.array(matrix_b1).reshape(n,1)
    
def Matrix_x(matrix_A,matrix_b):
    A_inv = np.linalg.inv(matrix_A)
    ans = A_inv.dot(matrix_b)
    return ans

def Matrix_x_Pseudo(matrix_A,matrix_b):
    A_inv = np.linalg.pinv(np.mat(matrix_A))
    ans = np.dot(A_inv,matrix_b)
    print("-------------Pseudo-------------")
    return ans

def Matrix_x_Singular(n,matrix_A,matrix_b):    
    Augmented = Matrix(np.hstack((matrix_A,matrix_b)))
    matrix_rref = np.array(Augmented.rref()[0])
    print("matrix_rref : ",matrix_rref)
    count = 0
    for i in range (n):        
        if max(matrix_rref[n-(i+1)]) == 0:                                   # 判斷有幾列整列皆是0
            count += 1 
    for i in range (n):  
        position_2 = -1    
        sum, p = 0, 1
        for j in range (t+2*k+1): 
            if position_2 == -1:                                             # 判斷有沒有找到第一個1在哪個位置
                if matrix_rref[n-(i+1)][j] == 1:                             # 判斷1在哪個位置
                    position_2 = j                                           # 要解的未知數的位置
                    if position_2 == (t+2*k):
                        answer.append(matrix_rref[n-(i+1)][j+1])
                        for z in range (count):                              # 通解的未知數全部設0，0的個數count決定
                            answer.append(0)  
                        count = 0      
            else:               
                sum += -1*matrix_rref[n-(i+1)][j]*answer[(t+2*k+1)-(j+1)]    # (j+1)+(x+1)-1 = t+2*k+1，從頭或從尾開始算
                p += 1
        if count == 0 and position_2 != (t+2*k):
            sum += matrix_rref[n-(i+1)][t+2*k+1]
            answer.append(sum)                
    return np.array(answer).reshape(t+2*k+1,1)


# ------------------------------------Main program------------------------------------
check_n = 1
fun_s = []
share = []
error = []
matrix_A1 = []
matrix_A2 = []
matrix_b1 = []
answer = []

print("-------------------Start-------------------")

s = int(input("Secret : "))
t = int(input("The degree of f(x) : "))

while (check_n):
    n = int(input("The number of parties (n > 2t) : "))
    check_n = Check_n(n,t)

k = int((n-t-1)/2)
print("The maximum of the number of error : ",k)

f_coeff = Fun_sender(t)
print("The Coefficient of f(x) = ", f_coeff)

shares = Share(n,t,f_coeff,s)
print("The shares are : ",shares)

num_e = int(input("\nHow many errors happen : "))
shares_err = Error(num_e,shares)
print("\nThe shares are redefined : ",shares_err)

matrix_A = Matrix_A(shares_err,k,t,n)
print("\nMatrix A : \n",matrix_A)

matrix_b = Matrix_b(shares_err,k,n)
print("Matrix b : \n",matrix_b)

if t+2*k+1 == n:
    if np.linalg.det(matrix_A) == 0:
        matrix_x = Matrix_x_Singular(n,matrix_A,matrix_b)   # 列的排序反了
        solution = 2
    else:
        matrix_x = Matrix_x(matrix_A,matrix_b)  
        solution = 1 
else:
    matrix_x = Matrix_x_Pseudo(matrix_A,matrix_b)
    solution = 1
print("Matrix x : \n",matrix_x)




x = symbols('x')           # 這邊順序有點問題，要改
if solution == 1:    
    if k == 3 :
        print("Answer : ",factor(x**3 + int(matrix_x[2][0])*x**2 + int(matrix_x[1][0])*x - int(matrix_x[0][0])))
    elif k == 2:
        print("1 ",x**2 + round(matrix_x[1][0])*x + round(matrix_x[0][0]))
        print("Answer : ",factor(x**2 + round(matrix_x[1][0])*x + round(matrix_x[0][0])) )
    elif k == 1:
        print("Answer : ",factor(x + int(matrix_x[0][0])*1) )


elif solution == 2:                        
    print("2 ",x**2 + int(matrix_x[n-2][0])*x + int(matrix_x[n-1][0]))
    if k == 3 :
        print("Answer : ",factor(x**3 - int(matrix_x[n-3][0])*x**2 + int(matrix_x[n-2][0])*x + int(matrix_x[n-1][0])))
    elif k == 2:
        print("Answer : ",factor(x**2 + int(matrix_x[n-2][0])*x + int(matrix_x[n-1][0])) )
    elif k == 1:
        print("Answer : ",factor(x + int(matrix_x[n-1][0])) )

print("-------------------END-------------------")
