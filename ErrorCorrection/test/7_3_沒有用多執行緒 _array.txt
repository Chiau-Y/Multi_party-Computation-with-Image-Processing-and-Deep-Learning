import cv2
import random
import numpy as np
from sympy import * 
from numpy.polynomial import Polynomial as P
import time

start_time = time.time()
# ------------------------------------Subroutine------------------------------------
def Check_n(n,t):                                                            # 設定party個數                   
    if n < 2*t or n <= 0:
        print("You need more parties")
        check = 1
    else:
        check = 0
    return check

def Matrix_A(shares_err,k,t,n):                                              # A矩陣
    matrix_A1, matrix_A2 = np.array([]), np.array([])
    share = shares_err
    k1 = k
    for i in range (n):
        matrix_A1 = np.append(matrix_A1,share[i])
        for j in range (k-1):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            matrix_A1 = np.append(matrix_A1,share[i]*power)   
    for i in range (n):
        matrix_A2 = np.append(matrix_A2,-1)
        num = 0
        for j in range (t+k):
            power = 1
            for z in range (j+1):
                power *= (i+1)
            matrix_A2 = np.append(matrix_A2,(-1)*power) 
    if k == 0:
        k1 += 1
    return np.append(matrix_A1.reshape(n,k1), matrix_A2.reshape(n, t+k+1), axis=1) 

def Matrix_b(share,k,n):                                                    # b矩陣
    matrix_b1 = np.array([])
    for i in range (1,n+1):
        power = 1
        for j in range (k):
            power *= i            
        matrix_b1 = np.append(matrix_b1,share[i-1]*power*(-1))      
    return matrix_b1.reshape(n,1)
    
def Matrix_x(matrix1,matrix2):                                             # 矩陣求解
    # print("\n===== Square and Non-Singular Matrix=====")
    Augmented = Matrix(np.hstack((matrix1,matrix2)))
    A_inv = np.linalg.inv(matrix1)
    ans = A_inv.dot(matrix2)
    return ans

def Matrix_x_Pseudo(matrix1,matrix2):                                      # 非方正矩陣求解
    # print("\n===== Non-square Matrix =====")
    A_inv = np.linalg.pinv(np.mat(matrix1))
    ans = np.dot(A_inv,matrix2)   
    return np.array(ans)

def Matrix_x_Singular(n,matrix1,matrix2):                                  # 奇異矩陣求解
    answer = np.array([])
    # print("\n===== Singular Matrix =====")
    Augmented = Matrix(np.hstack((matrix1,matrix2))).applyfunc(nsimplify)  
    matrix_rref = np.array(Augmented.rref()[0])
    # print(matrix_rref)
    count = 0
    for i in range (n):        
        if max(matrix_rref[n-(i+1)]) == 0:                                   # 判斷有幾列整列皆是0
            count += 1 
    for i in range (n):  
        position_2 = -1    
        sum, p = 0, 1
        for j in range (t+2*k+1): 
            if position_2 == -1:                                             # 判斷有沒有找到第一個1在哪個位置
                if matrix_rref[n-(i+1)][j] == 1:                             # 判斷1在哪個位置
                    position_2 = j                                           # 要解的未知數的位置
                    if position_2 == (t+2*k):
                        answer = np.append(answer,matrix_rref[n-(i+1)][j+1])
                        for z in range (count):                              # 通解的未知數全部設0，0的個數count決定
                           answer = np.append(answer,0)  
                        count = 0      
            else:               
                sum += -1*matrix_rref[n-(i+1)][j]*answer[(t+2*k+1)-(j+1)]    # (j+1)+(x+1)-1 = t+2*k+1，從頭或從尾開始算
                p += 1
        if count == 0 and position_2 != (t+2*k):
            sum += matrix_rref[n-(i+1)][t+2*k+1]
            answer = np.append(answer,sum)  
    return answer.reshape(t+2*k+1,1)

def Reshape(matrix):                                                     # 重新排列矩陣
    matrix_x1 = np.array([])
    for i in range (t+2*k+1):
        matrix_x1 = np.append(matrix_x1,matrix[t+2*k+1-(i+1)][0])
    return matrix_x1.reshape(t+2*k+1,1)   

def Solution(matrix,flag):                                               # 多項式求解(error)
    solution2,solve1 = np.array([]), np.array([1])
    for i in range (k):
        solve1 = np.append(solve1,matrix[(k-1)-i][0])
    solve2 = np.poly1d(np.array(solve1))
    solution1 = solve2.roots                                                
    for i in range (k):
        if flag :    # Non-square Matrix 
            if int(solution1[i].real) > 0 and solution1[i] <= n and isinstance(solution1[i], (int, float)):
                solution2 = np.append(solution2,int(round(solution1[i])))
        else:
            if solution1[i] > 0 and solution1[i] <= n :
                solution2 = np.append(solution2,int(round(solution1[i])))
    return solution2, solve2

def Orinignal_fun(matrix1,matrix2,matrix3,matrix4):
    solve3 = np.array([])
    for i in range (t+k+1):
        solve3 = np.append(solve3,matrix_x[((t+2*k+1)-1)-i][0]) 
    solve4 = list(P(solve3)//P(matrix4))
    solve5 = np.poly1d(solve4)
    for i in range (len(matrix2)):
        matrix3[int(matrix2[i])-1] = int(round(solve5(int(matrix2[i]))))
    return matrix3, solve5

#------------------------------------ Image to Array ----------------------------------#
def Image2Array(img_party):  
    
    img_gray = np.zeros([img_size[0], img_size[1]], dtype='float32')
    
    for i in range (img_size[0]):       
        for j in range(img_size[1]): 
            img_gray[i][j] = int(img_party[:,:,0][i][j]) + int(img_party[:,:,1][i][j]) + int(img_party[:,:,2][i][j])
    
    return img_gray 

# ------------------------------------Main program------------------------------------
check_n, Flag_Pseudo = True, False
matrix_A1, matrix_A2, matrix_b1, matrix_x1 = [], [], [], []
answer, solve1, solution2, solve3, solution3 = [], [], [], [], []
t = 1                                                                 # 次方

print("\n-------------------Start-------------------")        

# party1 = cv2.imread('./parties/party1.bmp')  
# party2 = cv2.imread('./parties/party2_original.bmp')
# party3 = cv2.imread('./parties/party3.bmp')
# party4 = cv2.imread('./parties/party4.bmp')
# party5 = cv2.imread('./parties/party5.bmp')
# # party6 = cv2.imread('./parties/party6.bmp')   

# print("Image to Array")
# img_size = np.shape(party1)
# party1_gray = Image2Array(party1)  
# party2_gray = Image2Array(party2) 
# party3_gray = Image2Array(party3) 
# party4_gray = Image2Array(party4) 
# party5_gray = Image2Array(party5) 
# party6_gray = Image2Array(party6)  

shares = [171.0, 171.0, 171.0, 174.0, 175.0, 176]
# shares.append(party1_gray[50][50])
# shares.append(party2_gray[50][50])
# shares.append(party3_gray[50][50])
# shares.append(party4_gray[50][50])
# shares.append(party5_gray[50][50])
# # shares.append(party6_gray[50][50])

print("Error Correction\n")
for y in range(200):
    while (check_n):
        n = len(shares)
        check_n = Check_n(n,t)                                                  # party數(n)
    # print("There are {} parties.".format(n))                                  
    # print("\nShares are ",shares)
    
    k = int((n-t-1)/2)
    # print("\nThe maximum of the number of error : ",k)                            # 錯誤數量最大值(k_max)  
           
    matrix_A = Matrix_A(shares,k,t,n)                                          # 矩陣A
    # print("\nMatrix A : \n",matrix_A)
    
    matrix_b = Matrix_b(shares,k,n)                                            # 矩陣b
    # print("\nMatrix b : \n",matrix_b)
    
    if t+2*k+1 == n:
        if abs(np.linalg.det(matrix_A)) < 1e-06:    
            matrix_x_1 = Matrix_x_Singular(n,matrix_A,matrix_b)   
            matrix_x = Reshape(matrix_x_1)
        else:
            matrix_x = Matrix_x(matrix_A,matrix_b)  
    else:
        matrix_x = Matrix_x_Pseudo(matrix_A,matrix_b)                           # 解答(矩陣x)
        Flag_Pseudo = True
    # print("\nMatrix x : \n",matrix_x)
    
    error_party, fun_e = Solution(matrix_x, Flag_Pseudo)                        # 錯誤的party
    error_party.sort()
    if len(error_party) == 0:
        # print("\nThere is no error in shares.\n")
        shares_corret, fun_org = Orinignal_fun(matrix_x,error_party,shares,fun_e)
        # print("\nThe f(x) is : \n",fun_org)
    else:
        # print("\nThe error party is : ", error_party)
        shares_corret, fun_org = Orinignal_fun(matrix_x,error_party,shares,fun_e)
        # print("\nThe correct shares are : ",shares_corret)
        # print("\nThe f(x) is : \n",fun_org)

end_time = time.time()     
print("")        
print("Time : ",round(end_time-start_time, 2),"sec") 

print("\n-------------------END-------------------\n")